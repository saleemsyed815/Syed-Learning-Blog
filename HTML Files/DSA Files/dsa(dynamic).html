<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../CSS Files/DSA Files/dsa(dynamic).css">
    <title>Dynamic Programming</title>
</head>
<body>
    <!-- Header -->
  <section id="header" style="background-color:black">
    <div class="header container">
      <div class="nav-bar">
        <div class="brand">
          <a href="#hero">
            <h1><span>SYED</span> Learning</h1>
          </a>
        </div>
        <div class="nav-list">
          <div class="hamburger">
            <div class="bar"></div>
          </div>
          <ul>
            <li><a href="../../index.html" data-after="Home">Home</a></li>
            <li><a href="../../index.html#services" data-after="Courses">Courses</a></li>
            <li><a href="../../index.html#projects" data-after="Projects">Quiz</a></li>
            <li><a href="../../index.html#contact" data-after="Contact">Contact</a></li>
            <li><a href="#" data-after="Login">Login</a></li>
          </ul>
        </div>
      </div>
    </div>
  </section>
  <!-- End Header -->

  <!-- Columns -->
  <div class="column">
    <div class="column left">
      <h1 class="headings">All Topics</h1>
      <ul>
        <li><a href="../DSA Files/dsa(intro).html" class="v2"><p>Introduction</p></a></li>
        <li><a href="../DSA Files/dsa(link).html" class="v2"><p>Linked List</p></a></li>
        <li><a href="../DSA Files/dsa(variant).html" class="v2"><p>Variants of LL</p></a></li>
        <li><a href="../DSA Files/dsa(stackandqueue).html" class="v2"><p>Stacks and Queues</p></a></li>
        <li><a href="../DSA Files/dsa(treeandgraph).html" class="v2"><p>Trees and Graph</p></a></li>
        <li><a href="../DSA Files/dsa(algo).html" class="v2"><p>Algorithms</p></a></li>
        <li><a href="../DSA Files/dsa(recursive).html" class="v2"><p>Recursive - Divide and Conquer</p></a></li>
        <li><a href="../DSA Files/dsa(greedy).html" class="v2"><p>Greedy Algorithms</p></a></li>
        <li><a href="../DSA Files/dsa(dynamic).html" class="v2"><p>Dynamic Programming</p></a></li>
        <li><a href="../DSA Files/dsa(branch).html" class="v2"><p>Branch and Bound</p></a></li>
        <li><a href="../DSA Files/dsa(back).html" class="v2"><p>Backtracking</p></a></li>
        <li><a href="../DSA Files/dsa(graph).html" class="v2"><p>Graph Algorithms</p></a></li>
      </ul>
    </div>
    <div class="column middle">
      <div class="vl"></div>
    </div>
      <div class="column right">
      <h1 class="heading">Dynamic Programming</h1>
      <br><br>
      <p>
        Dynamic Programming is an algorithmic paradigm that solves a given complex problem by breaking it into subproblems and stores the results of subproblems to avoid computing the same results again. Following are the two main properties of a problem that suggests that the given problem can be solved using Dynamic programming. <br><br>
        1) Overlapping Subproblems: <br>
        Like Divide and Conquer, Dynamic Programming combines solutions to sub-problems. Dynamic Programming is mainly used when solutions of the same subproblems are needed again and again. In dynamic programming, computed solutions to subproblems are stored in a table so that these don’t have to be recomputed. So Dynamic Programming is not useful when there are no common (overlapping) subproblems because there is no point storing the solutions if they are not needed again. For example, Binary Search doesn’t have common subproblems. If we take an example of following recursive program for Fibonacci Numbers, there are many subproblems that are solved again and again. <br><br>
        <textarea name="" id="" cols="60" rows="10">
                        fib(5)
                        /             \
                  fib(4)                fib(3)
                /      \                /     \
            fib(3)      fib(2)         fib(2)    fib(1)
            /     \        /    \       /    \
            fib(2)   fib(1)  fib(1) fib(0) fib(1) fib(0)
            /    \
            fib(1) fib(0)
        </textarea><br><br>
        We can see that the function fib(3) is being called 2 times. If we would have stored the value of fib(3), then instead of computing it again, we could have reused the old stored value. There are following two different ways to store the values so that these values can be reused: <br><br>
        a) Memoization (Top Down) <br><br>
        The memorized program for a problem is similar to the recursive version with a small modification that looks into a lookup table before computing solutions. We initialize a lookup array with all initial values as NIL. Whenever we need the solution to a subproblem, we first look into the lookup table. If the precomputed value is there then we return that value, otherwise, we calculate the value and put the result in the lookup table so that it can be reused later. <br><br>
        b) Tabulation (Bottom Up) <br><br>
        The tabulated program for a given problem builds a table in bottom-up fashion and returns the last entry from the table. For example, for the same Fibonacci number, we first calculate fib(0) then fib(1) then fib(2) then fib(3), and so on. So literally, we are building the solutions of subproblems bottom-up.  <br><br>

        Both Tabulated and Memoized store the solutions of subproblems. In Memoized version, table is filled on demand while in the Tabulated version, starting from the first entry, all entries are filled one by one. Unlike the Tabulated version, all entries of the lookup table are not necessarily filled in Memoized version. <br><br>
        Time taken by the Recursion method is much more than the two Dynamic Programming techniques mentioned above – Memorization and Tabulation! <br><br>

        2) Optimal Substructure: A given problems has Optimal Substructure Property if optimal solution of the given problem can be obtained by using optimal solutions of its subproblems. <br><br>
        For example, the Shortest Path problem has following optimal substructure property: 
        If a node x lies in the shortest path from a source node u to destination node v then the shortest path from u to v is combination of shortest path from u to x and shortest path from x to v. The standard All Pair Shortest Path algorithm like Floyd–Warshall and Single Source Shortest path algorithm for negative weight edges like Bellman–Ford are typical examples of Dynamic Programming. <br><br>
        On the other hand, the Longest Path problem doesn’t have the Optimal Substructure property. Here by Longest Path we mean longest simple path (path without cycle) between two nodes.         <br><br>

    </p>
      <br><br>
      <button class="nextbutton"><a href="../DSA Files/dsa(greedy).html">Previous</a></button>
      <div style="float:right;"> Hello</div>
      <button class="nextbutton1"><a href="../DSA Files/dsa(branch).html">Next Topic</a></button>
  </div>
</div>
    <!-- End Columns -->
    <section id="footer">
      <div class="footer container">
        <div class="brand">
          <h1><span>SYED</span> Learning</h1>
        </div>
        <h2>One Solution for many Problems</h2>
        <div class="social-icon">
          <div class="social-item">
            <a href="#"><img src="https://img.icons8.com/bubbles/100/000000/facebook-new.png" /></a>
          </div>
          <div class="social-item">
            <a href="#"><img src="https://img.icons8.com/bubbles/100/000000/instagram-new.png" /></a>
          </div>
          <div class="social-item">
            <a href="#"><img src="https://img.icons8.com/bubbles/100/000000/twitter.png" /></a>
          </div>
          <div class="social-item">
            <a href="#"><img src="https://img.icons8.com/bubbles/100/000000/behance.png" /></a>
          </div>
        </div>
        <p>Copyright © 2022 saleemsyed815. All rights reserved</p>
      </div>
    </section>
  <script src="../../JS Files/js.js"></script>
</body>
</html>